---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.1.3
  kernelspec:
    display_name: Python [conda env:pytorch] *
    language: python
    name: conda-env-pytorch-py
---

```{python}
import sys
import os

if os.getcwd().split('/')[-1]!='dsbowl':
    os.chdir('dsbowl')

import random
import warnings

import matplotlib.pyplot as plt
import numpy as np
import cv2

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.tensorboard import SummaryWriter
from torch.nn.functional import binary_cross_entropy

from modules.dataset import load_train_data, load_test_data
from modules.preds import create_submission
from modules.metrics import mean_iou
from modules.transforms import get_train_tfms, get_test_tfms
from modules.transforms_functional import tensor_to_img
from modules.nets import Net, OneCycleScheduler
from modules.model_factory import get_model
from modules.files import get_sizes, getNextFilePath
import config as cfg
```

```{python}
tl, vl = load_train_data(cfg.TRAIN_PATH, size=cfg.TRAIN_SIZE, bs=cfg.BATCH_SIZE,
                         transforms=get_train_tfms(cfg.TRAIN_SIZE), use_augs=False, shuffle=False)
```

```{python}
ts = tl.dataset
```

```{python}
ts.show(5, transformed=True)
```

```{python}
ts.show(5, transformed=False)
```

```{python}
dls = {'train': tl, 'val': vl}
```

```{python}
device = 'cuda:0' if torch.cuda.is_available() else 'cpu'

mod = get_model(cfg.MODEL, cfg.CLASSES, act=cfg.ACT)
opt = optim.Adam(mod.parameters(), lr=cfg.LRS[0], weight_decay=cfg.WD)
net = Net(mod, opt, nn.BCELoss(), [mean_iou], cfg.MODELS_PATH)
```

```{python}
scheduler = OneCycleScheduler(cfg.LRS, len(tl))
save_name = f'{cfg.MODEL}_{cfg.EPOCHS}_{cfg.LRS[0]}_{cfg.WD}'
save_name += f'_{getNextFilePath(cfg.MODELS_PATH, save_name)}'
print(save_name)
```

```{python}
writer = SummaryWriter(log_dir='/work/stages/schwob/runs/'+save_name)
```

```{python}
writer.add_graph(mod, input_to_model=next(iter(tl))[0], operator_export_type='RAW')
```

```{python}
l = []
for name, module in mod.named_modules():
    if name=='encoder.layer4':
        break
    if isleaf(module):
        l.append(name)
print('\n'.join(l))
```

```{python}
for name, param in mod.named_parameters():
    print(name)            
```

```{python}
sizes = get_sizes(cfg.TRAIN_CSV, vl.dataset.ids)
sizes.shape
```

```{python}
net.load(cfg.MODELS_PATH/save_name)
```

```{python}
ts.show(0, transformed = True)
```

```{python}
X, y_true = ts[3]
```

```{python}
y_pred = net.model(X.unsqueeze(0)).detach().squeeze(0)
```

```{python}
img = tensor_to_img(X)
mask_true = tensor_to_img(y_true)
mask_pred = tensor_to_img(y_pred)
plt.figure(0, (15, 15))
plt.subplot(131)
plt.axis('off')
plt.imshow(img)
plt.subplot(132)
plt.axis('off')
plt.imshow(mask_true)
plt.subplot(133)
plt.axis('off')
plt.imshow(mask_pred>0.5)
```

```{python}
print(mean_iou(y_pred, y_true))
print(binary_cross_entropy(y_pred, y_true))
```

```{python}
for m in net.model:
    print(m)
```

```{python}
class c:
    def __init__(self):
        self.a = []
    
def test(k, d=10):
    if d > 0:
        b = c()
        print(b)
        k.a.append(b)
        test(b, d-1)
        
def test1(k, d=10):
    if d>0:
        print(k.a[0])
        test1(k.a[0], d-1)
```

```{python}
k = c()
test(k)
print()
test1(k)
```

```{python}
def test2(s):
    s.lower()
```

```{python}
a = 'ABCDE'
```

```{python}
import sys
s = 'a'
t = 'a'
sys.getsizeof(s[-1])
```

```{python}
k = 0
s='a'
t='a'
while s is t:
    k += 1
    s = 'a'*k
    t = 'a'*k
k
```

```{python}
k=2
s='a'*k
t='a'*k
s is t
```

```{python}
class c:
    def __init__(self):
        self.a = 1
d = c()
sys.getsizeof(d)
```

```{python}
from string import ascii_lowercase, ascii_uppercase
for k in range(1, 100):
    for l in ascii_lowercase:
        d.__setattr__(l*k, l*k)
sys.getsizeof(d)
```

```{python}
for l in ascii_uppercase:
    d.__setattr__(l*2, l*2)
sys.getsizeof(d)
```

```{python}
d.__getattribute__('a')
```

```{python}

```
